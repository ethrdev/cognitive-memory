<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>4</storyId>
    <title>Claude Code Fallback für Haiku API Ausfall (Degraded Mode)</title>
    <status>drafted</status>
    <generatedAt>2025-11-18</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>bmad-docs/stories/3-4-claude-code-fallback-fuer-haiku-api-ausfall-degraded-mode.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>MCP Server</asA>
    <iWant>bei totalem Haiku API Ausfall auf Claude Code Evaluation zurückfallen</iWant>
    <soThat>das System weiterhin funktioniert (wenn auch mit leicht reduzierter Konsistenz)</soThat>
    <tasks>
### Task 1: Database Schema Migration für fallback_status_log (AC: 3.4.2)
- Create migration file `009_fallback_status_log.sql`
- Define table schema mit allen required columns (timestamp, service_name, status, reason, metadata)
- Add indexes für Performance (timestamp DESC, service_name, status)
- Add validation queries für Fallback-Historie abfragen
- Execute migration on PostgreSQL database (MANUAL: User execution required)

### Task 2: Implement Fallback-Trigger Logic (AC: 3.4.1)
- Modify `mcp_server/external/anthropic_client.py`
- Catch `FallbackRequiredException` (created in Story 3.3) in `evaluate_answer()` caller
- Implement `_claude_code_fallback_evaluation()` method in anthropic_client.py
- Fallback-Prompt: Same evaluation criteria as Haiku (Relevance, Accuracy, Completeness)
- Parse Claude Code Response (structured JSON: {reward, reasoning})
- Return same format as Haiku Evaluation (consistency)

### Task 3: Implement Fallback-Status Logging (AC: 3.4.2)
- Create `mcp_server/utils/fallback_logger.py` module
- Function `log_fallback_activation(service_name, reason, metadata)` → inserts into fallback_status_log
- Function `log_fallback_recovery(service_name)` → inserts recovery event
- Function `get_current_fallback_status()` → returns active fallbacks (query helper)
- Integrate logging calls in anthropic_client.py Fallback-Trigger (Task 2)
- Add Warning-Message generation in MCP Tool Response

### Task 4: Implement Health Check und Auto-Recovery (AC: 3.4.3)
- Create `mcp_server/health/haiku_health_check.py` module
- Async function `periodic_health_check()` → ping Haiku API alle 15 Minuten
- Lightweight Health Check: Simple API call (minimaler Request)
- On Success → Call `log_fallback_recovery()` + deactivate Fallback-Flag
- On Failure → Log Warning (but don't trigger new Fallback, avoid infinite loop)
- Integrate Health Check in MCP Server startup (`__main__.py`)
- Background Task: `asyncio.create_task(periodic_health_check())` in server initialization

### Task 5: Global Fallback-State Management (AC: 3.4.1, 3.4.3)
- Create `mcp_server/state/fallback_state.py` module
- In-Memory State: `haiku_evaluation_fallback_active = False` (module-level variable)
- Function `activate_fallback(service_name)` → set flag, log activation
- Function `deactivate_fallback(service_name)` → unset flag, log recovery
- Function `is_fallback_active(service_name) -> bool` → check current state
- Integrate state checks in anthropic_client.py (use fallback if active)
- Ensure thread-safe access (asyncio.Lock if needed)

### Task 6: Fallback-Quality Dokumentation (AC: 3.4.4)
- Create `/docs/fallback-strategy.md` documentation file
- Section 1: Overview (Why Fallback, When Triggered)
- Section 2: Quality Trade-offs (5-10% Konsistenz-Reduktion, Session-State Variabilität)
- Section 3: Recovery Strategy (Auto-Recovery alle 15 min, kein Manual Override)
- Section 4: Monitoring (Wie prüfe ich Fallback-Status? PostgreSQL queries)
- Section 5: Testing (Simuliere Haiku API Ausfall, verify Fallback aktiviert)

### Task 7: Testing and Validation (All ACs)
- Manual Test: Simulate Haiku API total failure (mock API unavailable)
- Verify Fallback triggered (Claude Code Evaluation used)
- Verify `fallback_status_log` populated (status='active')
- Verify Warning-Message displayed to User
- Verify Health Check runs periodically (15-minute intervals)
- Manual Test: Simulate API recovery (mock API back online)
- Verify Fallback deactivated (status='recovered')
- Verify Claude Code Evaluation returns same format as Haiku (reward, reasoning)
- Verify Fallback-Quality (compare Haiku vs. Claude Code scores auf Test-Queries)
    </tasks>
  </story>

  <acceptanceCriteria>
### AC-3.4.1: Fallback-Trigger und Claude Code Evaluation

**Given** Haiku API ist nach 4 Retries nicht erreichbar (Story 3.3 Retry-Logic)
**When** Fallback zu Claude Code getriggert wird
**Then** wird alternative Evaluation durchgeführt:
- **Fallback-Modus:** Claude Code führt Self-Evaluation intern durch
- **Prompt:** Gleiche Evaluation-Kriterien wie Haiku (Relevance, Accuracy, Completeness)
- **Output:** Reward Score -1.0 bis +1.0 (gleiche Skala wie Haiku)
- **Format:** Structured JSON Response mit `{reward: float, reasoning: string}` Struktur
- **Temperature:** 0.0 (deterministisch wie Haiku Evaluation)

### AC-3.4.2: Fallback-Status Logging

**And** Fallback-Status wird in PostgreSQL geloggt:
- **Tabelle:** Neue Tabelle `fallback_status_log` mit Columns: timestamp, service_name, status, reason, metadata
- **Migration:** Schema-Migration 009 (`009_fallback_status_log.sql`)
- **Logging:** Jeder Fallback-Aktivierung/Recovery wird persistiert
- **Query-Support:** Claude Code kann Fallback-Historie abfragen

**And** Warning-Message an User wird generiert:
- **Format:** "⚠️ System running in degraded mode (Haiku API unavailable). Using Claude Code evaluation as fallback."
- **Display:** Im MCP Tool Response als Warning-Field
- **Persistence:** Warning bleibt aktiv bis Recovery erfolgt

### AC-3.4.3: Automatische Health Check und Recovery

**And** automatische Recovery nach API-Wiederherstellung:
- **Health Check:** Background-Task ping Haiku API alle 15 Minuten (Lightweight Call, Async Scheduled Task)
- **Recovery-Prozedure:** Falls Health Check erfolgreich → Deaktiviere Fallback, Log Recovery-Event, Info-Message an User
- **No Manual Intervention:** Komplett automatisch (kein User-Action erforderlich)

### AC-3.4.4: Fallback-Quality Dokumentation und Trade-offs

**And** Fallback-Quality wird dokumentiert:
- **Erwartete Konsistenz-Reduktion:** Claude Code Evaluation ~5-10% weniger konsistent als Haiku
- **Trade-off Dokumentation:** Verfügbarkeit (99% Uptime) > perfekte Konsistenz (100% Score-Konsistenz)
- **Dokumentation Location:** `/docs/fallback-strategy.md` (neu erstellt)
  </acceptanceCriteria>

  <artifacts>
    <docs>
<!-- Epic Documentation -->
<doc>
  <path>bmad-docs/epics.md</path>
  <title>i-o - Epic Breakdown</title>
  <section>Story 3.4: Claude Code Fallback für Haiku API Ausfall (Degraded Mode)</section>
  <snippet>Als MCP Server, möchte ich bei totalem Haiku API Ausfall auf Claude Code Evaluation zurückfallen, sodass das System weiterhin funktioniert (wenn auch mit leicht reduzierter Konsistenz). Expected degraded mode: 5-10% Konsistenz-Reduktion akzeptabel, aber 99% Uptime garantiert. Auto-Recovery alle 15 Minuten via Health Check.</snippet>
</doc>

<!-- Architecture Documentation -->
<doc>
  <path>bmad-docs/architecture.md</path>
  <title>Cognitive Memory System v3.1.0-Hybrid - Architektur</title>
  <section>Error Handling Strategy</section>
  <snippet>External APIs: Retry-Logic mit Exponential Backoff (1s, 2s, 4s, 8s, max 4 retries). Fallback: Haiku API Ausfall → Claude Code Evaluation (degraded mode). No Fallback: OpenAI Embeddings (kritisch, kein Fallback möglich). Logging: JSON Structured Logs mit timestamp, level, api_name, error_type.</snippet>
</doc>

<doc>
  <path>bmad-docs/architecture.md</path>
  <title>Cognitive Memory System v3.1.0-Hybrid - Architektur</title>
  <section>Architecture Decision Records (ADR-002: Strategische API-Nutzung)</section>
  <snippet>Bulk-Operationen (Query Expansion, CoT) → intern in Claude Code (€0/mo). Kritische Evaluationen (Dual Judge, Reflexion) → externe APIs (€5-10/mo). Fallback: Claude Code Evaluation bei Haiku API Ausfall (€0/mo, graceful degradation). True IRR: GPT-4o + Haiku = echte unabhängige Dual Judges (Kappa >0.70).</snippet>
</doc>

<!-- Previous Story (Story 3.3) Documentation -->
<doc>
  <path>bmad-docs/stories/3-3-api-retry-logic-enhancement-mit-exponential-backoff.md</path>
  <title>Story 3.3: API Retry-Logic Enhancement mit Exponential Backoff</title>
  <section>Completion Notes List</section>
  <snippet>Story 3.3 enhanced existing retry logic infrastructure with database logging. Created FallbackRequiredException exception class for Story 3.4 fallback trigger. Retry decorator applied to evaluate_answer() with max_retries=4, delays=[1,2,4,8], jitter=True. All external APIs now have robust retry logic.</snippet>
</doc>
    </docs>

    <code>
<!-- Existing Code to Reuse -->
<artifact>
  <path>mcp_server/external/anthropic_client.py</path>
  <kind>module</kind>
  <symbol>FallbackRequiredException</symbol>
  <lines>25-33</lines>
  <reason>Custom exception created in Story 3.3 for fallback trigger. Raised after max retries when Haiku API unavailable. Story 3.4 catches this exception to implement degraded mode.</reason>
</artifact>

<artifact>
  <path>mcp_server/external/anthropic_client.py</path>
  <kind>module</kind>
  <symbol>HaikuClient.evaluate_answer</symbol>
  <lines>88-100</lines>
  <reason>Existing Haiku evaluation method with @retry_with_backoff decorator. Story 3.4 wraps this with fallback handler to catch FallbackRequiredException and trigger Claude Code evaluation.</reason>
</artifact>

<artifact>
  <path>mcp_server/utils/retry_logic.py</path>
  <kind>module</kind>
  <symbol>retry_with_backoff</symbol>
  <lines>29-100</lines>
  <reason>Retry decorator with exponential backoff (Story 3.3). Already applied to evaluate_answer(). Provides 4 retries before raising FallbackRequiredException. Story 3.4 relies on this for fallback trigger.</reason>
</artifact>

<artifact>
  <path>mcp_server/db/connection.py</path>
  <kind>module</kind>
  <symbol>get_connection</symbol>
  <lines>1-50</lines>
  <reason>PostgreSQL connection pool pattern. Story 3.4 reuses for fallback_status_log queries in fallback_logger.py module. Context manager for safe database operations.</reason>
</artifact>

<artifact>
  <path>mcp_server/db/migrations/008_api_retry_log.sql</path>
  <kind>migration</kind>
  <symbol>api_retry_log table</symbol>
  <lines>1-118</lines>
  <reason>Migration pattern to follow for 009_fallback_status_log.sql. Shows table creation, indexes (timestamp DESC, api_name, partial index), comments, and validation queries. Story 3.4 follows same structure.</reason>
</artifact>

<artifact>
  <path>mcp_server/__main__.py</path>
  <kind>entrypoint</kind>
  <symbol>MCP Server Entry Point</symbol>
  <lines>1-50</lines>
  <reason>MCP server startup file. Story 3.4 modifies to integrate Health Check background task: asyncio.create_task(periodic_health_check()). Non-blocking background task for API recovery monitoring.</reason>
</artifact>

<!-- New Modules to Create -->
<artifact>
  <path>mcp_server/utils/fallback_logger.py</path>
  <kind>module</kind>
  <symbol>NEW MODULE</symbol>
  <lines>N/A</lines>
  <reason>Task 3: Centralized fallback logging utilities. Functions: log_fallback_activation(), log_fallback_recovery(), get_current_fallback_status(). Writes to fallback_status_log table using connection pool pattern.</reason>
</artifact>

<artifact>
  <path>mcp_server/health/haiku_health_check.py</path>
  <kind>module</kind>
  <symbol>NEW MODULE</symbol>
  <lines>N/A</lines>
  <reason>Task 4: Periodic health check for Haiku API recovery. Async function periodic_health_check() pings API every 15 minutes. On success: deactivate fallback. On failure: log warning (don't retrigger fallback). Prevents infinite fallback loops.</reason>
</artifact>

<artifact>
  <path>mcp_server/state/fallback_state.py</path>
  <kind>module</kind>
  <symbol>NEW MODULE</symbol>
  <lines>N/A</lines>
  <reason>Task 5: Global fallback state management. Module-level variable: haiku_evaluation_fallback_active = False. Functions: activate_fallback(), deactivate_fallback(), is_fallback_active(). Thread-safe with asyncio.Lock if needed.</reason>
</artifact>

<artifact>
  <path>mcp_server/db/migrations/009_fallback_status_log.sql</path>
  <kind>migration</kind>
  <symbol>NEW MIGRATION</symbol>
  <lines>N/A</lines>
  <reason>Task 1: Database schema for fallback tracking. Table: fallback_status_log (timestamp, service_name, status, reason, metadata). 3 indexes: timestamp DESC, service_name, status. Follows pattern from 008_api_retry_log.sql.</reason>
</artifact>

<artifact>
  <path>docs/fallback-strategy.md</path>
  <kind>documentation</kind>
  <symbol>NEW DOCUMENTATION</symbol>
  <lines>N/A</lines>
  <reason>Task 6: Fallback quality and trade-offs documentation. Sections: Overview, Quality Trade-offs (5-10% consistency reduction), Recovery Strategy (auto-recovery every 15 min), Monitoring (PostgreSQL queries), Testing (simulate API outage). Audience: ethr (operator) and future developers.</reason>
</artifact>
    </code>

    <dependencies>
<!-- Python Dependencies from pyproject.toml -->
<python>
  <package name="python" version="^3.11" />
  <package name="mcp" version="^1.0.0" />
  <package name="anthropic" version="^0.25.0" required="true" />
  <package name="asyncio" version="built-in" required="true" />
  <package name="psycopg2-binary" version="^2.9.0" />
  <package name="python-dotenv" version="^1.0.0" />
  <package name="pyyaml" version="^6.0" />
</python>

<!-- Development Dependencies -->
<dev-dependencies>
  <package name="black" version="^23.0.0" />
  <package name="ruff" version="^0.1.0" />
  <package name="mypy" version="^1.7.0" />
  <package name="pytest" version="^7.4.0" />
  <package name="pytest-asyncio" version="^0.21.0" />
</dev-dependencies>
    </dependencies>
  </artifacts>

  <constraints>
## Development Constraints

### Architecture Constraints
1. **Exception-Based Fallback Pattern:** Use FallbackRequiredException from Story 3.3 as trigger mechanism. Catch in calling code, activate fallback state, log activation, call Claude Code evaluation. Do NOT use return-code-based checks or inline if/else logic.

2. **Async/Await Throughout:** All fallback handler methods, health check, and logging functions must be async. Use AsyncAnthropic client. Background task: asyncio.create_task() in __main__.py startup.

3. **Database Connection Pool:** Reuse existing get_connection() pattern from mcp_server/db/connection.py. Use context manager for safe database operations. Do NOT create new connection pools.

4. **Migration Pattern:** Follow 008_api_retry_log.sql structure exactly: CREATE TABLE IF NOT EXISTS, indexes (timestamp DESC, service_name, status), COMMENT ON TABLE/COLUMN, validation queries section.

5. **Graceful Degradation:** Fallback logging failures must NOT break API calls. Use try/except around database writes. Log errors but continue execution.

### Implementation Constraints
1. **Global State Management:** Module-level variable in fallback_state.py. Use asyncio.Lock for thread-safe access if multiple async tasks access state concurrently.

2. **Health Check Constraints:**
   - Run every 15 minutes (900 seconds)
   - Use lightweight API call (minimal tokens)
   - On success: deactivate fallback, log recovery
   - On failure: log warning ONLY (do NOT trigger new fallback - prevents infinite loop)

3. **Claude Code Evaluation Format:** Must return EXACTLY same structure as Haiku: `{reward: float, reasoning: string}`. Add optional `fallback: true` flag to indicate degraded mode.

4. **Warning Message Format:** "⚠️ System running in degraded mode (Haiku API unavailable). Using Claude Code evaluation as fallback." Include in MCP Tool response as warning field.

### Testing Constraints
1. **Manual Testing:** No automated tests required (Story 3.3 pattern). Manual test steps documented in story Dev Notes.

2. **Migration Execution:** User must manually execute: `psql -U mcp_user -d cognitive_memory -f mcp_server/db/migrations/009_fallback_status_log.sql`

3. **Quality Comparison:** Test 20 queries (10 Haiku, 10 Claude Code) to validate 5-10% consistency variance acceptable.

### Code Quality Constraints
1. **DRY Principle:** Reuse existing patterns (retry_logic decorator, connection pool, migration structure). Do NOT duplicate code.

2. **Logging Levels:**
   - INFO: Fallback activated, fallback recovered, health check success
   - WARNING: Degraded mode active (user-facing), health check failure
   - ERROR: Critical failures (database connection lost, etc.)

3. **Type Hints:** Use Python 3.11+ type hints throughout (str | None, dict[str, Any], etc.).

4. **Docstrings:** Comprehensive docstrings for all new functions/classes with Args, Returns, Raises, Example sections.
  </constraints>

  <interfaces>
## Existing Interfaces to Reuse

### Haiku Client Interface (anthropic_client.py)
```python
@retry_with_backoff(max_retries=4, base_delays=[1.0, 2.0, 4.0, 8.0])
async def evaluate_answer(
    self, query: str, context: List[str], answer: str
) -> Dict[str, Any]:
    """
    Returns: {
        "reward": float,        # -1.0 to +1.0
        "reasoning": str,       # Haiku's explanation
        "model": str,           # "claude-3-5-haiku-20241022"
        "timestamp": str        # ISO 8601 timestamp
    }
    Raises: FallbackRequiredException after 4 failed retries
    """
```

### Database Connection Interface (connection.py)
```python
def get_connection():
    """
    Context manager for PostgreSQL connections.

    Usage:
        with get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute(query, params)
                conn.commit()

    Raises: DatabaseConnectionError if connection fails
    """
```

### Retry Decorator Interface (retry_logic.py)
```python
def retry_with_backoff(
    max_retries: int = 4,
    base_delays: List[float] | None = None,
    jitter: bool = True,
) -> Callable[[F], F]:
    """
    Decorator for exponential backoff retry logic.

    Retryable conditions: HTTP 429, 503, Timeout
    Logs to api_retry_log table on retry attempts

    Final failure: Raises original exception (or FallbackRequiredException if configured)
    """
```

## New Interfaces to Implement

### Fallback State Interface (state/fallback_state.py)
```python
async def activate_fallback(service_name: str) -> None:
    """Activate fallback mode for specified service (haiku_evaluation | haiku_reflexion)"""

async def deactivate_fallback(service_name: str) -> None:
    """Deactivate fallback mode after API recovery"""

async def is_fallback_active(service_name: str) -> bool:
    """Check if fallback mode currently active for service"""
```

### Fallback Logger Interface (utils/fallback_logger.py)
```python
async def log_fallback_activation(
    service_name: str, reason: str, metadata: dict[str, Any]
) -> None:
    """Log fallback activation to database. Insert row with status='active'"""

async def log_fallback_recovery(service_name: str) -> None:
    """Log fallback recovery to database. Insert row with status='recovered'"""

async def get_current_fallback_status() -> list[dict[str, Any]]:
    """Query active fallbacks from database. Returns list of {service_name, status, timestamp}"""
```

### Health Check Interface (health/haiku_health_check.py)
```python
async def periodic_health_check() -> None:
    """
    Background task that runs every 15 minutes.

    - Ping Haiku API with lightweight call
    - If success: deactivate fallback, log recovery
    - If failure: log warning (do NOT trigger new fallback)

    Never raises exceptions (catches all errors internally)
    """
```

### Claude Code Fallback Evaluation (anthropic_client.py - new method)
```python
async def _claude_code_fallback_evaluation(
    query: str, answer: str, context: list[str]
) -> dict[str, Any]:
    """
    Internal fallback evaluation using Claude Code.

    Returns: {
        "reward": float,        # -1.0 to +1.0 (same scale as Haiku)
        "reasoning": str,       # Claude Code's explanation
        "model": str,           # "claude-code-internal"
        "fallback": True        # Flag indicating degraded mode
    }

    Uses same evaluation criteria as Haiku: Relevance, Accuracy, Completeness
    Temperature 0.0 for determinism
    """
```
  </interfaces>

  <tests>
    <standards>
Manual testing approach (consistent with Story 3.3 pattern). No automated unit tests required for personal project. Testing focuses on:

1. **Schema Migration Validation:** Execute migration, verify table creation with `\d fallback_status_log`, check indexes
2. **Functional Testing:** Simulate API failures, verify fallback trigger, check database logs
3. **Integration Testing:** End-to-end workflow with API outage simulation and recovery
4. **Quality Validation:** Compare Haiku vs Claude Code evaluation scores (20 test queries)

Testing follows architecture.md testing strategy (lines 419-433): Manual testing in Claude Code interface, no automated tests for Stories 1-2, validation testing for Epic 3.
    </standards>

    <locations>
- Manual testing: Claude Code interface (MCP Tool calls)
- Test queries: bmad-docs/testing/ (if created)
- Migration validation: PostgreSQL psql commands
- No automated test directory required
    </locations>

    <ideas>
<!-- Mapped to Acceptance Criteria -->

**AC-3.4.1: Fallback-Trigger Tests**
- Test 1: Simulate Haiku API total failure (mock 503 on all 4 retries) → verify FallbackRequiredException caught → verify Claude Code evaluation called → verify response format matches Haiku
- Test 2: Verify fallback state set to active → subsequent evaluations skip Haiku and use Claude Code directly
- Test 3: Verify Claude Code evaluation returns {reward: float, reasoning: str, fallback: true}

**AC-3.4.2: Fallback-Logging Tests**
- Test 4: Verify fallback_status_log table populated after fallback trigger → check columns (timestamp, service_name='haiku_evaluation', status='active', reason='haiku_api_unavailable')
- Test 5: Verify Warning-Message displayed in MCP Tool response: "⚠️ System running in degraded mode..."
- Test 6: Query fallback history: `SELECT * FROM fallback_status_log ORDER BY timestamp DESC LIMIT 10;`

**AC-3.4.3: Health Check Tests**
- Test 7: Verify health check runs periodically (wait 15 min, check logs for ping attempts)
- Test 8: Simulate API recovery (mock successful ping) → verify fallback deactivated → verify recovery event logged (status='recovered')
- Test 9: Verify next evaluation after recovery uses Haiku (not Claude Code fallback)
- Test 10: Health check failure during degraded mode → verify only logs warning, does NOT retrigger fallback

**AC-3.4.4: Quality Tests**
- Test 11: Run 10 evaluations with Haiku, 10 with Claude Code fallback on same queries → calculate variance
- Test 12: Verify variance ≤10% (acceptable degradation)
- Test 13: Verify documentation exists at docs/fallback-strategy.md with all required sections

**Edge Cases**
- Test 14: Concurrent evaluations during fallback → all use Claude Code consistently
- Test 15: Database write failure during log_fallback_activation → verify doesn't break evaluation flow
- Test 16: Health check network timeout → verify graceful handling without triggering new fallback
    </ideas>
  </tests>
</story-context>
