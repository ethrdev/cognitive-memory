<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>4</storyId>
    <title>L0 Raw Memory Storage (MCP Tool: store_raw_dialogue)</title>
    <status>drafted</status>
    <generatedAt>2025-11-12</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>bmad-docs/stories/1-4-l0-raw-memory-storage-mcp-tool-store-raw-dialogue.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Claude Code</asA>
    <iWant>vollständige Dialogtranskripte in PostgreSQL speichern</iWant>
    <soThat>der komplette Konversationsverlauf persistent ist und für spätere Komprimierung/Suche verfügbar ist</soThat>
    <tasks>
  - store_raw_dialogue Tool Implementation (AC: 1, 2, 3)
    * Replace stub implementation in `mcp_server/tools/__init__.py` (lines 66-81)
    * Import database connection: `from mcp_server.db.connection import get_connection`
    * Implement parameter validation against JSON Schema
    * Add SQL INSERT with RETURNING clause for id and timestamp
    * Implement error handling for psycopg2 errors and validation failures

  - JSON Schema Verification (AC: 2)
    * Verify existing JSON Schema matches requirements (session_id, speaker, content, metadata)
    * Ensure metadata is optional and properly validated as JSONB

  - Error Handling Implementation (AC: 3)
    * Catch psycopg2.Error and return structured MCP error responses
    * Handle parameter validation errors with clear error messages
    * Implement connection pool error handling

  - Unit Tests für store_raw_dialogue (AC: 1, 2, 3, 4)
    * Create `tests/test_store_raw_dialogue.py` with comprehensive test cases
    * Test valid insertion, metadata handling, parameter validation, DB errors

  - Integration Test: MCP Tool Call End-to-End (AC: 1, 2, 3)
    * Extend `tests/test_mcp_server.py` with store_raw_dialogue end-to-end test
    * Test via MCP stdio transport subprocess

  - Documentation Updates (AC: all)
    * Update README.md with usage example
    * Document API parameters and response format
</tasks>
  </story>

  <acceptanceCriteria>
Given: Der MCP Server läuft und PostgreSQL ist verbunden
When: Claude Code das Tool `store_raw_dialogue` aufruft mit Parametern (session_id, speaker, content, metadata)
Then: Werden folgende Requirements erfüllt:

1. Datenpersistierung in l0_raw Tabelle:
   - Alle Felder korrekt persistiert: session_id, speaker, content, metadata
   - Timestamp automatisch generiert (UTC) via PostgreSQL DEFAULT NOW()
   - Session-ID als VARCHAR(255) für Gruppierung vorhanden
   - Metadata als JSONB gespeichert (flexible Struktur)
   - ID als SERIAL PRIMARY KEY auto-increment

2. Parameter-Validierung:
   - session_id REQUIRED, format: UUID oder frei wählbarer String
   - speaker REQUIRED, erlaubte Werte: "user" oder "assistant" oder custom
   - content REQUIRED, keine Längen-Limitation (TEXT type)
   - metadata OPTIONAL, muss valid JSON sein

3. Erfolgsbestätigung und Error Handling:
   - Response enthält generierte ID (int)
   - Response enthält Timestamp (ISO 8601 format)
   - Bei DB-Fehler: Clear error message mit MCP Error Response
   - Bei Parameter-Validierung Fehler: JSON Schema Validation Error

4. Performance und Indizierung:
   - Index auf (session_id, timestamp) existiert bereits (Story 1.2)
   - Keine Validierung von Content-Länge (kann sehr lang sein)
   - Connection Pool wird wiederverwendet (Story 1.3)
</acceptanceCriteria>

  <artifacts>
    <docs>
    <doc path="bmad-docs/tech-spec-epic-1.md" title="Epic Technical Specification: MCP Server Foundation" section="Daten-Modelle und Contracts" snippet="PostgreSQL Schema für l0_raw Tabelle: id SERIAL PRIMARY KEY, session_id VARCHAR(255), speaker VARCHAR(50), content TEXT, metadata JSONB, timestamp TIMESTAMPTZ DEFAULT NOW()"/>
    <doc path="bmad-docs/architecture.md" title="Cognitive Memory System Architecture" section="Datenbank-Schema" snippet="l0_raw Tabelle speichert Raw Dialogtranskripte mit Index auf (session_id, timestamp) für schnelle Abfragen"/>
    <doc path="bmad-docs/stories/1-2-postgresql-pgvector-setup.md" title="PostgreSQL + pgvector Setup" section="Database Schema" snippet="CREATE TABLE l0_raw mit IVFFlat Index, pgvector Extension für nachfolgende Vektor-Suchen"/>
    <doc path="bmad-docs/stories/1-3-mcp-server-grundstruktur-mit-tool-resource-framework.md" title="MCP Server Grundstruktur" section="Tool Registration Pattern" snippet="Tool handler decorator außerhalb der Schleife, Parameter validation via JSON Schema, Error handling mit structured responses"/>
  </docs>
    <code>
    <file path="mcp_server/tools/__init__.py" kind="tool_implementation" symbol="handle_store_raw_dialogue" lines="66-81" reason="Stub implementation needs to be replaced with real database insertion logic"/>
    <file path="mcp_server/db/connection.py" kind="database_module" symbol="get_connection" lines="93-146" reason="Context manager for PostgreSQL connections using connection pool"/>
    <file path="mcp_server/db/connection.py" kind="database_module" symbol="initialize_pool" lines="37-91" reason="Connection pool initialization with health checks"/>
    <file path="tests/test_store_raw_dialogue.py" kind="test" symbol="new_file" reason="Unit tests for store_raw_dialogue tool - needs to be created"/>
    <file path="tests/test_mcp_server.py" kind="integration_test" reason="Will be extended with store_raw_dialogue end-to-end test"/>
    <file path="mcp_server/db/migrations/001_initial_schema.sql" kind="migration" reason="CRITICAL: session_id must be VARCHAR(255), not UUID as specified in Story 1.4"/>
  </code>
    <dependencies>
    <python name="psycopg2-binary" version="^2.9.9" purpose="PostgreSQL database adapter"/>
    <python name="jsonschema" version="optional" purpose="Parameter validation for JSON schemas"/>
    <system name="postgresql" version="15+" purpose="Database server with pgvector extension"/>
    <system name="python" version="3.11+" purpose="Runtime environment with type hints support"/>
    <dev_dependencies>
      <python name="black" version="^23.0.0" purpose="Code formatter"/>
      <python name="ruff" version="^0.1.0" purpose="Linter"/>
      <python name="mypy" version="^1.7.0" purpose="Type checker"/>
      <python name="pytest" version="^7.4.0" purpose="Testing framework"/>
    </dev_dependencies>
  </dependencies>
  </artifacts>

  <constraints>
  - MCP Protocol Requirements:
    * Tool responses must follow MCP Error Response format: {error, details, tool}
    * Parameter validation via JSON Schema before processing

  - Database Operations:
    * Use context manager for database connections: `with get_connection() as conn:`
    * Always use parameterized queries (%s placeholders) - NEVER string interpolation
    * Database transactions must be explicitly committed: `conn.commit()`
    * Import psycopg2 errors: `import psycopg2` for proper exception handling
    * Use DictCursor from connection pool for dictionary-like row access
    * Convert timestamp to ISO format: `timestamp.isoformat()` for JSON serialization

  - Code Quality Standards:
    * Type hints REQUIRED (mypy -- strict compliance)
    * Black + Ruff for code formatting and linting
    * Structured JSON logging to stderr for debugging
    * Error handling with try/except/finally blocks
</constraints>
  <interfaces>
  <interface name="store_raw_dialogue" kind="mcp_tool" signature="async def handle_store_raw_dialogue(arguments: Dict[str, Any]) -> Dict[str, Any]" path="mcp_server/tools/__init__.py">
    <param name="session_id" type="string" required="true" description="UUID oder frei wählbarer String für Session-Gruppierung"/>
    <param name="speaker" type="string" required="true" description="'user', 'assistant' oder custom speaker identifier"/>
    <param name="content" type="string" required="true" description="Dialoginhalt ohne Längenbeschränkung"/>
    <param name="metadata" type="object" required="false" description="Zusätzliche Metadaten als JSON"/>
    <returns>
      <field name="id" type="integer" description="Auto-generierte ID aus Datenbank"/>
      <field name="timestamp" type="string" format="ISO 8601" description="Zeitstempel der Speicherung"/>
      <field name="session_id" type="string" description="Echo des übergebenen session_id"/>
      <field name="status" type="string" description="'success' bei erfolgreicher Speicherung"/>
    </returns>
  </interface>
  <interface name="l0_raw_table" kind="database_schema" signature="CREATE TABLE l0_raw (id SERIAL PRIMARY KEY, session_id VARCHAR(255), speaker VARCHAR(50), content TEXT, metadata JSONB, timestamp TIMESTAMPTZ DEFAULT NOW())" path="database_schema">
    <constraint description="Index auf (session_id, timestamp) bereits vorhanden"/>
  </interface>
</interfaces>
  <tests>
    <standards>Unit Tests mit pytest Framework, Tests gegen echte PostgreSQL Datenbank (nicht Mock), Test-Database: cognitive_memory_test mit Cleanup nach jedem Test, Integration Tests via MCP stdio transport (subprocess-basiert), Helper-Funktionen für Test-Daten-Cleanup, Test Coverage für Edge Cases: Special Characters, Null Metadata, Missing Parameters</standards>
    <locations>tests/test_store_raw_dialogue.py (Unit Tests), tests/test_mcp_server.py (Integration Tests), Haupt-Test-Datenbank: cognitive_memory_test, Development-Datenbank: cognitive_memory_dev via .env.development</locations>
    <ideas>Test1: Valid Insertion mit allen Parametern → verify ID und Timestamp zurückgegeben, Test2: Metadata als JSONB → verify JSON serialization funktioniert, Test3: Missing Required Parameter → verify validation error, Test4: DB Connection Failure → verify error handling, Test5: Session Query → multiple Einträge inserten, session_id grouping verifizieren, Test6: Special Characters in Content → verify keine SQL injection möglich</ideas>
  </tests>
</story-context>
